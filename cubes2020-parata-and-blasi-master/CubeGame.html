<html>

<head>
	<title>Starting Code for 1st Project 2017</title>
	<style>
		@import url('https://fonts.googleapis.com/css?family=Rubik&display=swap');

		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

		.modal {
			display: none;
			position: fixed;
			z-index: 1;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
			overflow: auto;
		}

		/* Caratteristiche messaggio finale */
		.modal-content {
			margin: 15% auto;
			padding: 20px;
			width: 80%;
			background-color: #f0f0f0;
			opacity: 0.9;
		}

		#puzzle {
			text-align: center;
			color: #00f5ff;
			font-family: 'Rubik', sans-serif;
			font-size: 36px;
			font-weight: 400;
			line-height: 48px;
			text-shadow: -1px 0 #a2c3e2, 0 1px #a2c3e2, 1px 0 #a2c3e2, 0 -1px #a2c3e2;
		}
		#info{
			padding-right: 10%;
			padding-top: 10px;
			text-align: right;
			font-size: 24px;
		}
	</style>
	<script src="lib/three.min.js"></script>
	<script src="lib/stats.min.js"></script>
	<script src="lib/Coordinates.js"></script>
	<script src="lib/OrbitControls.js"></script>
</head>

<body>
	

	<div id="info">Cubi mancanti = <b id="cubiMancanti">Start!</b></div>

	<script>
		//GENERAL VARIABLE 
		var scene, camera, renderer, controls, stats;
		var matrix = [];
		var counter = 0;
		var cubiMancanti = 25;

		//CUBE VARIABLE
		var geometry;
		var mapMaterial;
		var playerMaterial;
		var cubeMap;
		var cubePlayer;
		var edge;
		var line;
		var cubePlayerPosition;
		var pivotCubePlayer;

		//CUBE LIGHT
		var spotLight;





		//return array with height data from img, taken from: http://danni-three.blogspot.it/2013/09/threejs-heightmaps.html
		function getHeightData(img, scale) {

			if (scale == undefined) scale = 1;

			var canvas = document.createElement('canvas');
			canvas.width = img.width;
			canvas.height = img.height;
			var context = canvas.getContext('2d');

			var size = img.width * img.height;
			//console.log(size);
			var data = new Float32Array(size);

			context.drawImage(img, 0, 0);

			for (var i = 0; i < size; i++) {
				data[i] = 0
			}

			var imgd = context.getImageData(0, 0, img.width, img.height);
			var pix = imgd.data;

			var j = 0;
			for (var i = 0; i < pix.length; i += 4) {
				var all = pix[i] + pix[i + 1] + pix[i + 2]; // all is in range 0 - 255*3
				data[j++] = scale * all / 3;
			}
			return data;
		}

		function Start() {
			scene = new THREE.Scene();

			InizializeRenderer(); //Inizializza il renderer
			InizializeCamera(); //Inizializza la camera
			InitializeCube(); //Inizializza i cubi
			CreateStats(); //Fa apparire gli stats della scena
			CreateMatrix(); //Crea la matrice assegnando false alle caselle vuote 	
			CreateMap(); //Crea la mappa in base alla matrice creata sopra
			DrawPlayer(); //disegna il player




			//Attivazione ascolto comandi per gli spostamenti del cubo
			document.addEventListener("keydown", onDocumentKeyDown, false);

			//Responsive window
			window.addEventListener("resize", onWindowResize, false);

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			//Coordinates.drawAllAxes();				//Per mostrare le coordinate nella scena

			controls = new THREE.OrbitControls(camera);
			controls.addEventListener('change', Render);


			// terrain
			var img = new Image();

			// load img source
			img.src = "textures/heightmap2.png";
			img.onload = function () {

				//get height data from img
				var data = getHeightData(img, 0.1);

			}


		}

		function Update() {
			requestAnimationFrame(Update);
			controls.update();
			stats.update();
			Render();
		}

		function Render() {
			renderer.render(scene, camera);
		}

		//INIZIALIZZA LE CARATTERISTICHE DEL RENDERER
		function InizializeRenderer() {
			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			document.body.appendChild(renderer.domElement);

		}

		//INIZIALIZZA LE CARATTERISTICHE DELLA CAMERA
		function InizializeCamera() {
			camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			camera.position.set(0, 6, -4);
			camera.lookAt(new THREE.Vector3(0, 0, 0));
		}

		//finalizza la creazione del player e lo aggiunge ad un suo pivot insieme alla luce creata
		function DrawPlayer() {
			cubePlayer.reciveShadow = true;
			cubePlayer.castShadow = true;
			cubePlayer.add(line);
			pivotCubePlayer = new THREE.Object3D();
			pivotCubePlayer.add(cubePlayer);
			pivotCubePlayer.position.set(0, 1, 0);
			CreateLight();
			pivotCubePlayer.add(spotLight);
			spotLight.position.set(0, 1, 0);
			spotLight.position.y = 1;
			scene.add(pivotCubePlayer);

		}
		//finalizza le caratteristiche del cubeMap
		function DrawMapCubes() {

			cubeMap.reciveShadow = true;
			cubeMap.castShadow = true;
			cubeMap.add(line);

		}
		//INIZIALIZZA LE CARATTERISTICHE DEI CUBI
		function InitializeCube() {
			geometry = new THREE.BoxGeometry(1, 1, 1);
			mapMaterial = new THREE.MeshLambertMaterial({
				color: 0xf5ad4b
			});
			playerMaterial = new THREE.MeshLambertMaterial({
				color: 0xff0000
			});

			cubeMap = new THREE.Mesh(geometry, mapMaterial);
			cubePlayer = new THREE.Mesh(geometry, playerMaterial);

			edges = new THREE.EdgesGeometry(geometry);
			line = new THREE.LineSegments(
				edges,
				new THREE.LineBasicMaterial({
					color: 0x000000
				})
			);
			DrawMapCubes();
		}


		//CREA GLI STATS DELLA SCENA
		function CreateStats() {
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);
		}

		//CREA LA LUCE
		function CreateLight() {
			spotLight = new THREE.PointLight(0xffffff, 1, 5);
		}

		//CREA LA MATRICE
		function CreateMatrix() {
			for (var i = 0; i < 6; i++) {
				matrix[i] = new Array(6);
			}

			for (var z = 0; z < 6; z++) {
				for (var x = 0; x < 6; x++) {
					matrix[z][x] = true;
				}
			}

			matrix[0][3] = false;
			matrix[1][1] = false;
			matrix[1][3] = false;
			matrix[1][5] = false;
			matrix[3][0] = false;
			matrix[3][1] = false;
			matrix[3][4] = false;
			matrix[4][1] = false;
			matrix[4][3] = false;
			matrix[5][3] = false;
			matrix[5][5] = false;

		}

		//CREA LA MAPPA IN BASE ALLA MATRICE 
		function CreateMap() {
			for (var z = 0; z < 6; z++) {
				for (var x = 0; x < 6; x++) {
					if (matrix[z][x] == true) {
						InitializeCube();
						scene.add(cubeMap);
						cubeMap.position.set(x, 0, z);
					}
				}
			}
		}
//interpreta i comandi ricevuti in input dalla tastiera
		function onDocumentKeyDown(event) {
			var keyCode = event.code;
			if (keyCode == 'KeyW') {
				cubeAnimation(0);
			} else if (keyCode == 'KeyS') {
				cubeAnimation(2);
			} else if (keyCode == 'KeyA') {
				cubeAnimation(1);
			} else if (keyCode == 'KeyD') {
				cubeAnimation(3);
			} else if (keyCode == 'Space') {
				window.location.reload(true);
			}
			Render();
		}



		//effettua l'animazione del cubo nello spostamento
		function cubeAnimation(dir) {
			var t = 0;
			switch (dir) {
				case 0: //avanti
					var intervallo = setInterval(function () {
						if (t > 4) {
							changeMaterial();
							clearInterval(intervallo);
						} else {
							cubePlayer.rotation.x = (90 * Math.PI / 180) / 4 * t;
							pivotCubePlayer.translateZ(0.2);
						}
						t++;
					}, 100);

					break;
				case 1: //sinistra
					var intervallo = setInterval(function () {
						if (t > 4) {
							changeMaterial();
							clearInterval(intervallo);
						} else {
							cubePlayer.rotation.z = (-90 * Math.PI / 180) / 4 * t;
							pivotCubePlayer.translateX(0.2);
						}
						t++;
					}, 100);
					break;

				case 2: //indietro
					var intervallo = setInterval(function () {
						if (t > 4) {
							changeMaterial();
							clearInterval(intervallo);
						} else {
							cubePlayer.rotation.x = (-90 * Math.PI / 180) / 4 * t;
							pivotCubePlayer.translateZ(-0.2);
						}
						t++;
					}, 100);
					break;

				case 3: //destra

					var intervallo = setInterval(function () {
						if (t > 4) {
							changeMaterial();
							clearInterval(intervallo);
						} else {
							cubePlayer.rotation.z = (90 * Math.PI / 180) / 4 * t;
							pivotCubePlayer.translateX(-0.2);
						}
						t++;
					}, 100);
					break;
			}


		}



		//cambia il materiale del cubo su cui si transita
		function changeMaterial() {

			for (var i = 0; i < scene.children.length; i++) {

				if (
					Math.abs(scene.children[i].position.x - pivotCubePlayer.position.x) < 0.1 //controllo asse x
					&&
					Math.abs(scene.children[i].position.z - pivotCubePlayer.position.z) < 0.1 //controllo asse y
					&&
					((scene.children[i].position.y == 0) //controllo asse z
						&&
						(scene.children[i].material.color.r != 0 && scene.children[i].material.color.g != 0 && scene.children[
							i].material.color.b != 0)) //controllo materiale cubo
				) {
					scene.children[i].material.color = new THREE.Color(0x0000ff);
					scene.children[i].material.emissive = new THREE.Color(0x0000ff);
					cubeMap.material.emissiveIntensity = 0.5;
					levelCompleted()
					decrease();
				}
			}
		}
		//Verifica se il gioco Ã¨ terminato
		function levelCompleted() {
			counter++;

			if (counter == 25) {
				console.log("Livello completato!");

				// Get the modal
				var modal = document.getElementById("myModal");

				// Get the button that opens the modal
				var btn = document.getElementById("myBtn");

				// Get the <span> element that closes the modal
				var span = document.getElementsByClassName("close")[0];

				modal.style.display = "block";
			}

		}
		//decrementa il contatore ogni volta che viene colorato un mapcube per completare il gioco.
		function decrease() {
			cubiMancanti--;
			document.getElementById('cubiMancanti').innerHTML = cubiMancanti;
		}


		Start();
		Update();
	</script>


	<div id="myModal" class="modal" style="display: none;">

		<!-- Modal content -->
		<div class="modal-content">
			<p id="puzzle">Puzzle completato!</p>
		</div>

	</div>
</body>

</html>